---
title: "üìë R"
type: toc
tags: []
---

`R` est un langage de programmation interpr√©t√© et un logiciel libre destin√© aux
statistiques et √† la science des donn√©es. Il fait partie de la liste des paquets
GNU3 et est √©crit en `C`, `Fortran` et `R`.

Le langage R est largement utilis√© par les statisticiens, les data miners, data
scientists pour le d√©veloppement de logiciels statistiques et l'analyse des
donn√©es.

`R` fournit un langage de commande tr√®s souple et ouvert : il est possible de
connecter R avec d‚Äôautres langages comme C, Fortran, Java, JavaScript, Python‚Ä¶
il est aussi possible d‚Äôappeler des fonctions R depuis Matlab, Excel, etc. De
plus, des connectiques pour tous les types de bases de donn√©es existent : RMySQL
ou ROracle, pour ne citer que les plus connus.

- [The tidyverse style guide](https://style.tidyverse.org/syntax.html?q=comment#comments)

1. les nombres, on parle de [[r.dt.num]] ;
2. les nombres complexes, on parle de [[r.dt.complex]] ;
3. les caract√®res, on parle de [[r.dt.chr]] ;
4. les bool√©en, on parle de [[r.dt.lgl]] ;
5. les donn√©es vides, on parle de [[r.dt.null]]

- Packages

to load a package use this method ~rpart::~ exemple avec le package rpart

###### --------------------------------------------------------------

title: Les fonctions levels et order dans R
type: star
tags: #R #code

---

> # Scinder la note en 2
>
> - levels
>   \_- order

## levels()

## order()

The R order function returns a permutation of the order of the elements of a vector. The syntax with summarized descriptions of the arguments is as follows:

```r
order(x, # Sequence of s of the same length
      decreasing = FALSE, # Whether to sort in increasing or decreasing order
      na.last = TRUE,     # Whether to put NA values at the beginning or at the end
      method = c("auto", "shell", "radix")) # Method to be used. Defaults to auto
```

D√©finition
Les facteurs sont des vecteurs un peu particuliers, facilitant la manipulation de donn√©es qualitatives (qu‚Äôelles soient num√©riques ou caract√®res). En effet, en plus de stocker les diff√©rents √©l√©ments comme un vecteur classique, il stocke √©galement l‚Äôensemble des diff√©rentes modalit√©s possibles dans un attribut accessible via la commande `levels`
Ils forment une classe d‚Äôobjets et b√©n√©ficient de traitements particuliers lors de leur manipulation et lors de l‚Äôutilisation de certaines fonctions. Les facteurs peuvent √™tre **non ordonn√©s** (homme, femme) ou **ordonn√©s** (niveaux de ski).
Cr√©ation de facteur
Il y a 2 possibilit√©s, la fonction `factor()` et `

```R
Y <- c("M", "F", "F", "M", "F")
y
# [1] "M" "F" "F" "M" "F"

yf <- factor(y)
yf
# [1] M F F M F
# Levels: F M
```

Il est possible de ¬´ regarder ¬ª les attributs de `yf`

```R
attributes(yf)
# $levels
# [1] "F" "M"
# $class
# [1] "factor"

levels(yf)
# [1] "F" "M"

nlevels(yf)
# [1] 2
```

Les `levels` correspondent aux modalit√©s du facteur `yf`. Il est possible de les modifier :

```R
levels(yf) <- c("Femme","Homme")
yf
# [1] Homme Femme Femme Homme Femme
# Levels: Femme Homme
```

Ainsi, on modifie le facteur original comprenant les modalit√©s F et H, elles deviennent respectivement Femme et Homme.

### Il est possible de modifier ces levels d√®s la cr√©ation de la fonction `factor` avec l‚Äôargument `labels`

---

Et √† pr√©sent, un exemple avec la fonction `as.factor()` :

```R
salto <- c(1:5,5:1)
salto
# [1] 1 2 3 4 5 5 4 3 2 1

salto.f <- as.factor(salto)
salto.f
# [1] 1 2 3 4 5 5 4 3 2 1
# Levels: 1 2 3 4 5
```

                              La fonction `ordered()`

La focntion `ordered()` permet de cr√©er des facteurs **ordonn√©s** :

```R
niveau <- ordered(c("d√©butant", "d√©butant", "champion", "champion", "moyen", "moyen", "moyen", "champion"), levels = c("d√©butant", "moyen", "champion"))

niveau
# [1] d√©butant d√©butant champion champion moyen moyen moyen
# [8] champion
# Levels: d√©butant < moyen < champion
```

Les facteurs ont certains avantages, mais aussi certaines **contraintes de manipulation**. En effet, par exemple, il n‚Äôest pas possible de modifier ou d‚Äôajouter un √©l√©ment si celui-ci n‚Äôest pas dans la liste des `levels` . Il faut d‚Äôabord modifier les modalit√©s possibles via la fonction `levels()` avant de pouvoir ajouter un nouvel √©l√©ment. Pour vous affranchir des contraintes li√©es √† l‚Äôutilisation des facteurs, vous pouvez √† tout moment repasser sur un vecteur classique en utilisant les fonctions correspondantes : `as.numeric()` pour des num√©riques, `as.character()` pour des caract√®res, etc.

                              Utilisez des facteurs pour repr√©senter la r√©alit√©

Lors de vos analyses statistiques, vous allez √™tre confront√© √† de nombreuses variables qualitatives cod√©es diff√©remment :

- sous forme de vecteurs de caract√®res (comme des stations m√©t√©o, etc.) ;
- sous forme de vecteurs num√©riques (comme des CSP o√π chaque num√©ro correspond √† une cat√©gorie particuli√®re, par exemple 1 : ouvriers ; 2 : cadres ; etc.).

Les facteurs vont nous permettre de mieux faire comprendre √† R que nous manipulons des variables qualitatives. Prenons l‚Äôexemple d‚Äôune variable `X` comportant des num√©riques :

```R
X <- c(rep(10,3),rep(12,2),rep(13,4))
X
# [1] 10 10 10 12 12 13 13 13 13
```

Il existe deux m√©thodes classiques pour savoir si un objet de type vecteur est une variable quantitative ou une variable qualitative sans afficher la totalit√© du vecteur. La premi√®re consiste √† interroger R sur le type :

```R
is.factor(X)
# [1] FALSE

is.numeric(X)
# [1] TRUE
```

La seconde consiste √† effectuer un r√©sum√© de la variable ( summary ). Quand il s‚Äôagit d‚Äôune variable quantitative, le minimum, le maximum, les quartiles et la moyenne sont affich√©s. Par contre, pour un facteur, le nombre d‚Äôobservations pour les six premiers niveaux de la variable qualitative est donn√© :

```R
summary(X)
# Min.   1st Qu.  Median   Mean   3rd Qu.  Max.
# 10.00  10.00    12.00    11.78  13.00    13.00
```

De mani√®re √©vidente, il s‚Äôagit bien ici d‚Äôune variable quantitative. La fonction `summary()` est particuli√®rement pratique pour d√©terminer les types au sein de tableaux de donn√©es (dataframe) issus d‚Äôune √©tape d‚Äôimportation. En effet, le r√©sum√© est propos√© variable par variable et il permet de rep√©rer rapidement les √©ventuelles erreurs de type pour les variables.

Le passage en facteur se fait simplement en utilisant la fonction `factor()` :

```R
Xqual <- factor(X)
Xqual
# [1] 10 10 10 12 12 13 13 13 13
# Levels: 10 12 13

summary(Xqual)
# 10 12 13
# 3  2  4
```

L‚Äôaffichage d‚Äôun facteur permet clairement de le distinguer d‚Äôun num√©rique par la pr√©sence des niveaux `levels` en fin d‚Äôaffichage. Il en est de m√™me pour le r√©sum√© fourni par `summary`.

                              Conversion d‚Äôun facteur en nnum√©rique

Le passage de facteur en num√©rique se fait en deux √©tapes. D‚Äôabord, il faut transforme le facteur en vecteur de type caract√®re, puis on transforme ce dernier en num√©rique. Si l‚Äôon transforme directement le facteur en num√©rique, les niveaux sont recod√©s dans l‚Äôordre (le premier niveau sera 1, le deuxi√®me 2, etc.) :

```R
## conversion avec recodage des modalit√©s
as.numeric(Xqual)
# [1] 1 1 1 2 2 3 3 3 3

## conversion sans recodage des modalit√©s : 2 √©tapes
provisoire <- as.character(Xqual)
provisoire
# [1] "10" "10" "10" "12" "12" "13" "13" "13" "13"

as.numeric(provisoire)
# [1] 10 10 10 12 12 13 13 13 13
```

# matrice

_Vid√©o_ :

Matrice = objet monotype
Tous les √©l√©ments de la matrice sont de m√™me modes. Une matrices de num√©riques, une matrices de caract√®res, une matrice de bool√©ens.

On peut concat√©ner 2 matrices ensemble avec la fonction `cbind()`. Pour cela, il faut que les 2 matrices aient le m√™me nombre de lignes. On peut √©galement utiliser la fonction `rbind()`, dans ce cas, il faut que les matrice aient le m√™me nombre de colonnes.

_Cours_ :

Les matrices - √©quivalentes aux matrices en math√©matiques - peuvent √™tre vues comme des tableaux de valeurs, √† double entr√©e. Une matrice est donc d√©finie par son nombre de lignes et de colonnes. Ce sont des objets monotypes, c‚Äôest-√†-dire de m√™me type pour tous ses √©l√©ments. Chaque valeur de la matrice peut √™tre rep√©r√©e par son num√©ro de ligne et son num√©ro de colonne. Les deux attributs intrins√®ques d‚Äôun objet R sont la **longueur** `length`, qui correspond ici au nombre total d‚Äô√©l√©ments de la matrice, et le mode `mode` , qui correspond ici au mode des √©l√©ments de cette matrice. Les matrices poss√®dent √©galement l‚Äôattribut de dimension `dim`, qui retourne le nombre de lignes et le nombre de colonnes.

## En r√©sum√©

- Les **matrices** sont des sortes de **tableaux monotypes √† deux dimensions** o√π chaque √©l√©ment est identifi√© par son **num√©ro de ligne** et son **num√©ro de colonne**.
- Vous pouvez **cr√©er** une matrice soit √† partir d‚Äôun objet existant (vecteur notamment), soit en d√©finissant directement les √©l√©ments via la fonction `matrix()`.
- Vous pouvez r√©aliser de nombreuses **op√©rations d‚Äôalg√®bre lin√©aire** via diff√©rents op√©rateurs ou fonctions.
- Il existe plusieurs fonctions permettant d‚Äôacc√©der aux **dimensions** (nombre de lignes, nombre de colonnes, etc.) et/ou de **concat√©ner** des matrices.

## Cr√©ation d‚Äôune matrice

Voici les principales fa√ßons de cr√©er une matrice. La plus utilis√©e est la fonction `matrix` qui prend en arguments le vecteur d‚Äô√©l√©ments et les dimensions - nombre de lignes ou de colonnes - de la matrice. Par d√©faut, R range les valeurs dans une matrice par colonne. Pour ranger les √©l√©ments par ligne, on utilise l‚Äôargument `byrow` :

```R
x <- matrix(c(1:6), nrow = 2, ncol = 3, byrow = TRUE)
x
#      [,1] [,2] [,3]
# [1,]    1    2    3
# [2,]    4    5    6

y <- matrix(1:2, ncol = 1)
y
#      [,1]
# [1,]    1
# [2,]    2

z <- matrix(3:1, ncol = 3)
z
#      [,1] [,2] [,3]
# [1,]    3    2    1
```

Lorsque la longueur du vecteur est diff√©rente du nombre d‚Äô√©l√©ments de la matrice, R remplit toute la matrice. Si le vecteur est trop grand, il prend les premiers √©l√©ments, si le vecteur est trop petit, R le r√©p√®te :

```R
m <- matrix(1:4, nrow = 3, ncol = 3)
m
#      [,1] [,2] [,3]
# [1,]    1    4    3
# [2,]    2    1    4
# [3,]    3    2    1
```

> Dans tous les cas, un message d‚Äôavertissement (Warning message) sera √©mis au moment de l‚Äôex√©cution de la ligne de code. De fa√ßon globale, les messages d‚Äôavertissement ne sont pas √† prendre √† la l√©g√®re. Cela signifie g√©n√©ralement que R a fait quelque chose (comme compl√©ter une matrice m√™me s‚Äôil manque des √©l√©ments), mais que ce quelque chose ne correspond pas forc√©ment √† ce vous attendiez initialement.

Il est possible de remplir une matrice d‚Äôun √©l√©ment unique sans avoir √† cr√©er le vecteur des √©l√©ments :

```R
un <- matrix(1, nrow = 2, ncol = 4)
un
#      [,1] [,2] [,3] [,4]
# [1,]    1    1    1    1
# [2,]    1    1    1    1
```

Un vecteur n‚Äôest pas consid√©r√© par R comme une matrice. Il est cependant possible de **transformer** un vecteur en une matrice **unicolonne** avec la fonction `as.matrix` :

```R
x <- seq(1, 10, by = 2)
x
# [1] 1 3 5 7 9

as.matrix(x)
#      [,1]
# [1,]    1
# [2,]    3
# [3,]    5
# [4,]    7
# [5,]    9
```

Il est bien √©videmment possible de cr√©er une matrice de caract√®res :

```R
matrix(c("A", "B", "C", "A"), ncol = 2)
#      [,1] [,2]
# [1,] "A"  "C"
# [2,] "B"  "A"
```

## Op√©rations entre matrices

Comme avec des matrices classiques, il est possible d‚Äôeffectuer diff√©rentes op√©rations sur et avec des matrices. Consid√©rons les deux matrices `m` et `n` suivantes :

```R
m <- matrix(1:4, ncol = 2)
m
#      [,1] [,2]
# [1,]    1    3
# [2,]    2    4

n <- matrix(3:6, ncol = 2, byrow = T)
n
#      [,1] [,2]
# [1,]    3    4
# [2,]    5    6
```

Vous pouvez additionner deux matrices de **m√™me dimension** :

```R
m + n
#      [,1] [,2]
# [1,]    4    7
# [2,]    7   10
```

Ou calculer le produit entre deux matrices, lorsque le **nombre de lignes de la premi√®re est √©gal au nombre de colonnes de la deuxi√®me**.

```R
# Produit √©l√©ment par √©l√©ment
m*n
#      [,1] [,2]
# [1,]    3   12
# [2,]   10   24
```

Et vous pouvez y appliquer toute une s√©rie d‚Äô**op√©rations math√©matiques**, qui vont s‚Äôeffectuer √©l√©ment par √©l√©ment :

```R
# Sinus √©l√©ment par √©l√©ment
sin(m)

# Exponentielle √©l√©ment par √©l√©ment

exp(m)

# Puissance quatri√®me √©l√©ment par √©l√©ment

m^4
```

Le tableau suivant donne les principales fonctions utiles en alg√®bre lin√©aire que vous pouvez √©galement utiliser :

Fonction Description
X%_%Y produit (matriciel) de matrices
t(X) transposition d‚Äôune matrice
diag(5) matrice identit√© d‚Äôordre 5
diag(vec) matrice diagonale avec les valeurs du vecteur `vec` dans la diagonale
crossprod(X, Y) produit crois√© (t(X)%_%Y)
det(X) d√©terminant de la matrice X
svd(X) d√©composition en valeurs singuli√®res
eigen(X) diagonalisation d‚Äôune matrice
solve(X) inversion de matrice
solve(A, b) r√©solution de syst√®me lin√©aire
chol(Y) d√©composition de Cholesky
qr(Y) d√©composition QR

## Autres fonctions utiles

Nous pr√©sentons dans ce paragraphe quelques fonctions utiles pour manipuler vos matrices :

### Dimensions : `dim()`, `nrow()`, `ncol()` donnent respectivement la dimension, le nombre de lignes et de colonnes de X.

```R
X <- matrix(1:6, ncol = 3)
X
#      [,1] [,2] [,3]
# [1,]    1    3    5
# [2,]    2    4    6

ncol(X)
# [1] 3

nrow(X)
# [1] 2

dim(X)
# [1] 2 3
```

Ces fonctions renvoient NULL si X est un vecteur.

### Concat√©nation : par colonne avec la fonction `cbind()`, par ligne avec la fonction `rbind()`.

```R
cbind(c(1, 2), c(3, 4))
#      [,1] [,2]
# [1,]    1    3
# [2,]    2    4
```

### La fonction `apply()` permet d‚Äôappliquer une fonction choisie aux lignes (MARGIN=1) ou aux colonnes (MARGIN=2) de la matrice. Par exemple :

```R
# Sommes par colonne

apply(X, MARGIN = 2, sum)
# [1] 3 7 11

# Moyennes par ligne

apply(X, 1, mean)
# [1] 3 4
```

# Liste

La liste est un objet R h√©t√©roclite, elle peut contenir :
‚Ä¢ Vecteurs de caract√®res ;
‚Ä¢ Vecteurs de num√©riques ;
‚Ä¢ Des matrices ;
‚Ä¢ Des listes

Lors de vos analyses statistiques, vous risquez d‚Äô√™tre confront√© √† la gestion de plusieurs donn√©es de **types diff√©rents** et potentiellement de **longueurs diff√©rentes**. Bien entendu, vous pourriez stocker tous ces √©l√©ments dans autant de vecteurs/variables/facteurs en fonction de vos besoins. Mais ne serait-il pas plus pratique d‚Äôavoir un seul objet permettant de stocker tous ces diff√©rents objets ? C‚Äôest ce √† quoi correspondent les **listes**.

Une liste est un ensemble ordonn√© d‚Äôobjets qui n‚Äôont pas toujours le m√™me mode ou la m√™me longueur. Les diff√©rents objets sont appel√©s des composantes et peuvent √™tre associ√©s √† un nom sp√©cifique (un peu comme une variable). Les listes ont les deux **attributs** des vecteurs (_length_ et _mode_) et l‚Äôattribut suppl√©mentaire **names**. Les listes sont des objets indispensables, car toutes les fonctions qui retournent plusieurs objets le font sous la forme d‚Äôune liste.

## Cr√©ation de listes

La fonction de base pour cr√©er une liste est la fonction `list()` :

```R
maliste <- list(c("A","B","C","A"),matrix(1:4,2,2))
maliste
# [[1]]
# [1] "A" "B" "C" "A"

# [[2]]
#      [,1] [,2]
# [1,]    1    3
# [2,]    2    4
```

Cette liste contient bien 2 objets et c‚Äôest bien une liste, comme nous pouvons le voir ci-dessous :

```R
length(maliste)
# [1] 2

mode(maliste)
# [1] "list"

is.list(maliste)
# [1] TRUE
```

Comme dit plus t√¥t, vous pouvez nommer les composantes de la liste, c‚Äôest-√†-dire associer un nom √† chaque objet de la liste pour pouvoir y acc√©der plus facilement via l‚Äôop√©rateur `$`. Ceci est faisable via la fonction `names()` :

```R
names(maliste) # pas de nom actuellement, la fonction retourne un NULL
# NULL

names(maliste) <- c("vec","mat")
names(maliste)
# [1] "vec" "mat"
```

Il est √©galement possible de cr√©er une liste en partant d‚Äôune liste vide.

```R
li <- list()
li
# list()

li[[1]] <- 1:4
li
# [[1]]
# [1] 1 2 3 4

li$nouv <- matrix(1:4,nrow=2)
li
# [[1]]
# [1] 1 2 3 4

# $nouv
#      [,1] [,2]
# [1,]    1    3
# [2,]    2    4
```

Comme la premi√®re composante n‚Äôa pas de nom, on retrouve `[[1]]` dans l‚Äôaffichage de la liste puis la composante `nouv`.

```R
names(li)
# [1] "" "nouv"
```

et les attributs de cette liste sont les noms.

## Fonctions utiles applicables aux listes

Comme les objets d‚Äôune liste n‚Äôont pas forc√©ment le m√™me type, il n‚Äôest pas possible de faire des calculs entre plusieurs listes. N√©anmoins, il existe quelques fonctions valides et utiles :

- `lapply()` applique une fonction (comme la moyenne, la variance, etc.) successivement √† chacune des composantes.
- `unlist()` cr√©e un seul vecteur contenant tous les √©l√©ments de la liste. Les √©l√©ments d‚Äôun vecteur √©tant n√©cessairement du m√™me mode, il faut faire attention √† la conversion automatique pratiqu√©e par R.
- `c(liste1,liste2)` concat√®ne deux listes.

## En r√©sum√©

- Une liste est un **ensemble ordonn√© d‚Äôobjets** qui n‚Äôont pas toujours le m√™me _mode_ ou la m√™me _longueur_.
- Il est possible d‚Äôassocier un nom √† un objet sp√©cifique de la liste.
- Plusieurs fonctions permettent d‚Äôeffectuer une action sur chaque √©l√©ment d‚Äôune liste.

# Quizz #1

## Q1 - Concernant les vecteurs, quelles affirmations parmi les suivantes sont vraies ?

- [] Les vecteurs peuvent contenir plusieurs types

> Les vecteurs sont monotypes, ils ne peuvent donc contenir qu'un seul type donn√©.

- [x] La longueur d'un vecteur peut √™tre obtenue via la fonction `length()`

Si vous avez un vecteur `a`, il suffit d'utiliser la fonction `length()` pour obtenir sa taille.

- [] `seq` permet de cr√©er un vecteur en r√©p√©tant plusieurs fois un ou plusieurs √©l√©ments

`seq` permet de g√©n√©rer une s√©quence de nombre √©galement r√©partis dans un intervalle donn√©. La fonction pour r√©p√©ter un ou plusieurs √©l√©ments un certain nombre de fois est `rep`.

- [x] `c()` permet de cr√©er un vecteur en sp√©cifiant les diff√©rents √©l√©ments de ce dernier

> `c` permet de cr√©er un vecteur en sp√©cifiant les √©l√©ments √† l'int√©rieur. Si par exemple je veux cr√©er le vecteur 1, 2, 3 : `a <- c(1, 2, 3)`.

## Q2 - Quel sera le r√©sultat affich√© dans la console suite √† l'ex√©cution des lignes suivantes :

```R
x <- c(rep(10, times = 3), seq(1, 5, by = 1), 1, 2, 3)
x
```

D√©composons l'instruction :

- `c(rep(10, times = 3)` va r√©p√©ter l'entier 10 trois fois, le d√©but sera donc `10, 10, 10`
- `seq(1, 5, by = 1)` va cr√©er une s√©quence de 1 √† 5, par 1. La suite sera donc `1, 2, 3, 4, 5`
- `1, 2, 3` correspondra simplement √† `1, 2, 3` √† la suite.
  Mis bout √† bout, on obtient : `10, 10, 10, 1, 2, 3, 4, 5, 1, 2, 3`

## Q3 - Concernant les facteurs, quelles affirmations parmi les suivantes sont vraies ?

- [x] Les facteurs sont des vecteurs particuliers pour des donn√©es qualitatives
- [ ] Les facteurs ne peuvent contenir qu'une seule modalit√©
- [x] Les diff√©rentes valeurs possibles d'un facteur peuvent √™tre obtenues via la fonction `levels()`
- [ ] Il n'est pas possible d'ordonner les niveaux d'un facteurs

> Les facteurs sont des vecteurs permettant la manipulation de donn√©es qualitatives. Par cons√©quence, ils prennent en compte plusieurs modalit√©s d'une variable qualitative. Les diff√©rentes modalit√©s peuvent d'ailleurs √™tre obtenus via la fonctions `levels()`. Il est tout √† fait possible d'ordonner un facteur, via la fonction `ordered()`.

## Q4 - La fonction pour transformer un vecteur en facteur est :

La fonction pour transformer un vecteur existant en facteur est `as.factor()`

## Q5 - Concernant les matrices, quelles affirmations parmi les suivantes sont vraies ?

- [x] Une matrice ne peut contenir qu'un seul type
- [x] On peut acc√©der √† un √©l√©ment d'une matrice via son indice de ligne et de colonne
- [] La fonction `length` permet d'avoir le nombre de lignes et de colonnes d'une matrice
- [x] Il est possible de cr√©er une matrice de caract√®res

> Une matrice peut √™tre vue comme une sorte de tableau, on peut donc acc√©der √† un √©l√©ment via son num√©ro de ligne/colonne. Elle ne peut contenir qu'un seul type, qui peut √™tre num√©rique, caract√®re, bool√©en, etc... Pour avoir les dimensions de la matrice (nombres de lignes et de colonnes), il faut utiliser la fonction `dim`.

Q6 - Quel sera le r√©sultat affich√© dans la console suite √† l'ex√©cution des lignes suivantes :

```r
m <- matrix(1, nrow = 3, ncol = 3)
vec <- c(1, 2, 3)
m[1, 3] = 3
m <- m + diag(vec)
t(m)
```

```R
     [,1]  [,2]  [,3]
[1,]    2     1     1
[2,]    1     3     1
[3,]    3     1     4
```

> √âvaluons ligne par ligne :

1. On cr√©e une matrice 3x3, remplie par des 1
2. On cr√©e un vecteur `vec` contenant les valeurs 1, 2 et 3
3. On remplace la valeur situ√©e √† la premi√®re ligne et √† la troisi√®me colonne de `m``par 3
4. on ajoute √† `m` une matrice dont la diagonale a les valeurs de `vec`

√Ä ce stade, la matrice stock√©e dans `m` est :

```R
     [,1]  [,2]  [,3]
[1,]    2     1     3
[2,]    1     3     1
[3,]    1     1     4
```

Dans la derni√®re ligne, on prend la transpos√©e de cette matrice. Ainsi, l'affichage final est bien :

```R
    [,1]  [,2]  [,3]
[1,]    2     1     1
[2,]    1     3     1
[3,]    3     1     4
```

## Q7 - Concernant les liste, quelles affirmations parmi les suivantes sont vraies ?

- [] Une liste ne peut contenir qu'un seul type

> Une liste peut contenir plusieurs types.

- [] Si j'utilise la fonction `length()` sur la liste suivante : `list(c("A", "B", "C", "A"), matrix(1:4, 2, 2))`. Celle-ci renverra bien la valeur 8.

> Dans l'exemple donn√©, la fonction `length()` renverra bien 2, car il y a uniquement deux objets : un vecteur et une matrice.

- [x] Lorsqu'ils sont nomm√©s, on peut acc√©der aux diff√©rents objets contenus dans une liste via l'op√©rateur `$`

> Lorsqu'ils sont nomm√©s, on peut acc√©der aux diff√©rents objets contenus dans une liste via l'op√©rateur `$`

- [x] On peut acc√©der aux diff√©rents objets d'une liste via leurs indices

> On peut acc√©der aux diff√©rents objets d'une liste via leurs indices

## Q8 - Concernant les dataframes, quelles affirmations parmi les suivantes sont vraies ?

- [x] Les dataframes sont des listes particuli√®res dont les composantes sont de m√™me taille

> Les dataframes sont des listes particuli√®res dont les composantes sont de m√™me taille.

- [] Les modes des diff√©rentes composantes d'un dataframe doivent √™tre tous identiques

> Les modes des diff√©rentes composantes d'un dataframe peuvent √™tre diff√©rents. Il faut voir un dataframe comme un tableau de donn√©es. Ainsi, on peut avoir une colonne repr√©sentant des valeurs quantitatives, une autre repr√©sentant une variable qualitative, etc...

- [x] On peut cr√©er un dataframe √† partir d'un tableau de donn√©es externe (.txt, .csv, etc...)

> On peut cr√©er un dataframe √† partir d'un tableau de donn√©es externe (.txt, .csv, etc...) via la fonction `read.table` que nous verrons prochainement.

- [] Il n'est pas possible de transformer une matrice en dataframe

> Il est possible de transformer une matrice en dataframe via la fonction `as.data.frame`

---

Lorsqu'on utilise des packages avec R, il est important d'appeler les fonctions du package avec le code suivant : `package::function`

```r
dplyr::select
# Permet d'utiliser la fonction select du package dplyr
```

Ainsi, il n'y a pas de collusion entre diff√©rentes fonctions poss√©dant le m√™me nom dans divers packages. Cette situation ne peut pas arriver si on utilise un seul package, mais il est rare de n'utiliser q'un seul package. Aussi, on pr√©f√©rera appeler la fonction avec son package.



## Qu‚Äôest-ce qu‚Äôun mod√®le ?

> faire le lien avec mes notes de formation data science de l‚ÄôENSAE

https://www.youtube.com/watch?v=qH_ltaEpQdE

https://www.banque-france.fr/sites/default/files/media/2021/07/02/methodologie_projections_macro_bdf.pdf

https://publications.banque-france.fr/le-modele-fr-bdf-et-une-evaluation-des-effets-de-la-politique-monetaire-en-france

https://www.banque-france.fr/sites/default/files/medias/documents/818334_rdb68_fr_v7.pdf#search=mod%C3%A8le%20mapi%20inflation

- pr√©sentation outil DPCM

---

title: Comment s√©lectionner un √©l√©ment dans R

# Familiarisez-vous avec la s√©lection d'√©l√©ments

En statistique, les donn√©es constituent le point de d√©part de toute analyse. Il est en effet tr√®s courant d‚Äôavoir √† s√©lectionner une partie de nos donn√©es, soit en s√©lectionnant manuellement un sous-√©chantillon (par exemple les 30 premi√®res lignes), soit selon une condition donn√©e (par exemple uniquement les femmes, ou les personnes de moins de 25 ans, etc.). Il est donc obligatoire de ma√Ætriser les op√©rations de s√©lection simples que nous pr√©sentons ici.

## En r√©sum√©

Il existe deux fa√ßons de s√©lectionner des √©l√©ments au sein d‚Äôun objet en R : soit via une s√©lection par position (ou indice), soit via une s√©lection par condition.

Les conditions peuvent √™tre construites en utilisant des op√©rateurs de comparaisons et/ou des op√©rateurs logiques.

## Principes de s√©lections

Il y a deux grands principes dans la s√©lection d‚Äô√©l√©ments d‚Äôun objet R :

- la s√©lection par **position** : il faut indiquer un ou plusieurs vecteurs de positions (ou d‚Äôindices), des √©l√©ments √† s√©lectionner ;

- la s√©lection par **condition** : il faut indiquer une condition (qui pourra √™tre construite via diff√©rents op√©rateurs de comparaison et des op√©rateurs logiques) et ne seront s√©lectionn√©s que les √©l√©ments satisfaisant cette condition.

Dans tous les cas, la s√©lection s‚Äôop√®re avec l‚Äôop√©rateur de s√©lection [ ].

### La s√©lection par condition

Nous reviendrons un peu plus en d√©tail dans les chapitres suivants sur la s√©lection par position, mais pour celle par condition, vous allez avoir besoin d‚Äôutiliser des op√©rateurs de comparaison pour construire vos conditions. Comme le nom le sugg√®re, les op√©rateurs de comparaison sont utilis√©s pour comparer deux valeurs. Il y en a six principaux :

- `==` √©gal √† (deux valeurs sont exactement pareilles)

- `!=` diff√©rent de

- `<` inf√©rieur √†

- `<=` inf√©rieur ou √©gal

- `>` sup√©rieur √†

- `>=` sup√©rieur ou √©gal

Voici quelques exemples avec des valeurs num√©riques :

```R

2 == 2 # -> TRUE

2 == 3 # -> FALSE

4 != 4 # -> FALSE

4!= 5 # -> TRUE

1 < 2 # -> TRUE

1 < 1 # -> FALSE

1 <= 1 # -> TRUE

3 > 4 # -> FALSE

5 > 4 # -> TRUE

5 >= 4 # -> TRUE

```

Et √† pr√©sent un exemple simple avec un vecteur :

```R

x <- -2:5

x > 0

# [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE

```

On voit bien que le r√©sultat est un vecteur de bool√©en, indiquant pour chaque √©l√©ment si la condition est vraie ou non.

Parfois, vous allez avoir besoin de conditions plus √©labor√©es, ou la condition va √™tre le r√©sultat de la combinaison de plusieurs expressions. C‚Äôest l√† qu‚Äôinterviennent les **op√©rateurs logiques**.

Ces op√©rateurs vont vous permettre de mixer plusieurs valeurs bool√©ennes : des valeurs bool√©ennes sp√©cifiques ou des r√©sultats d‚Äôexpression. Il y en a 3 :

- `&` : l‚Äôop√©rateur ET. Le r√©sultat final est vrai seulement lorsque toutes les conditions sont vraies. Par exemple : le r√©sultat de `condition1 & condition2` sera TRUE seulement si `condition1` est vraie ET `condition2` est √©galement vraie.

- `|` : l‚Äôop√©rateur OU. Le r√©sultat final est vrai lorsque au moins une des conditions est vraie. Par exemple : le r√©sultat de `condition1  | condition2` sera TRUE si `condition1` est vraie OU `condition2` est vraie.

- `!` : l‚Äôop√©rateur N‚ÄôEST PAS. Cela inverse simplement le r√©sultat de la condition donn√©e. Par exemple, le r√©sultat de `!(condition)` est vrai lorsque `condition` est faux.

Quelques exemples d‚Äôutilisation de ces op√©rateurs :

```R

TRUE & TRUE # TRUE

TRUE & FALSE # FALSE

FALSE & FALSE # FALSE

TRUE | FALSE # TRUE

TRUE | TRUE # TRUE

FALSE | FALSE # FALSE

!TRUE # FALSE

!FALSE # TRUE

```

---

# R

## S√©lection dans un vecteur

### En r√©sum√©

Il est possible de s√©lectionner au sein d‚Äôun vecteur selon :

- Un **vecteur d‚Äôentiers positifs** : dans ce cas, les entiers correspondent aux indices des √©l√©ments √† s√©lectionner ;
- Un **vecteur d‚Äôentiers n√©gatifs** : dans ce cas, les entiers correspondent aux indices des √©l√©ments √† exclure du r√©sultat final ;
- Une **condition** : dans ce cas, le r√©sultat sera constitu√© de l‚Äôensemble des √©l√©ments du vecteur initial qui satisfont cette condition.

---

La s√©lection au sein d‚Äôun vecteur s‚Äôop√®re avec l‚Äô**op√©rateur de s√©lection** `[ ]` et un vecteur de s√©lection pouvant √™tre un vecteur d‚Äôentiers positifs, d‚Äôentiers n√©gatifs ou de logiques :

```R
x[vecteurdeselection]
```

## S√©lection par position

La s√©lection la plus naturelle est la s√©lection par des vecteurs d‚Äô**entiers positifs**. Les entiers sont les **indices** des √©l√©ments √† s√©lectionner et doivent √™tre compris entre 1 et la longueur du vecteur consid√©r√© (obtenue via la fonction `length()`). La longueur du vecteur d‚Äôindices peut √™tre quelconque :

```R
x <- c(2,-1,15)
x[2] # donne le deuxi√®me √©l√©ment de x
# [1] -1

x[c(1,3)] # donne les premier et troisi√®me √©l√©ments de x
# [1] 2 15

x[c(3,1,2,2,1)]
# [1] 15 2 -1 -1 2
```

Une autre m√©thode consiste √† enlever les √©l√©ments du vecteur que l‚Äôon ne souhaite pas conserver : c‚Äôest la s√©lection par des vecteurs d‚Äô**entiers n√©gatifs**. Le vecteur d‚Äôindices indique les indices des √©l√©ments √† exclure du r√©sultat final :

```R
x[-2] # ne donne pas le deuxi√®me √©l√©ment de x
# [1] 2 15
```

**??????** Une autre fa√ßon de proc√©der consiste √† s√©lectionner des √©l√©ments du vecteur en fonction de leur valeur ou d‚Äôautres √©l√©ments provenant d‚Äôautres objets R. Cela conduit √† la s√©lection par des vecteurs de logiques.

## S√©lection par condition

Cette s√©lection permet l‚Äôextraction d‚Äô√©l√©ments particuliers que l‚Äôon sait caract√©riser par une p√©riphrase ou par une condition logique :

- L‚Äô√©l√©ment de sgenre masculin (M);
- L‚Äô√©l√©ment qui poss√®de une valeur inf√©rieure √† 5 et (ou) sup√©rieure ou √©gale √† 12.

Prenons par exemple les √©l√©ments de `x` qui sont positifs.

```r
x[x>0]
# [1] 2 15

x[!(x<0)]
# [1] 2 15
```

Cependant, aucun √©l√©ment n‚Äôest √† la fois inf√©rieur √† 5 et sup√©rieur √† 12, la fonction retourne
alors l‚Äôensemble vide avec `integer(0)` :

```r
x[(x<5) & (x>=12)]
# numeric(0)
```

On peut aussi s√©lectionner les valeurs d‚Äôun vecteur √† partir des valeurs d‚Äôun autre vecteur de m√™me longueur :

```R
T <- c(23, 28, 24, 32)
O3 <- c(80, 102, 87, 124)
O3[T>25]
# [1] 102 124
```

#########

# S√©lection dans un dataframe

Tout comme la cr√©ation, la s√©lection dans les dataframes est √† mi-chemin entre la s√©lection dans les matrices et celle dans les listes. Commen√ßons par cr√©er un dataframe :

```R
x <- c("A","B","C",rep("D",3))
y <- 1:6
z <- c(seq(10,45,length=5),-10)
mondf <- data.frame(x,y,z)
mondf
#   x y      z
# 1 A 1  10.00
# 2 B 2  18.75
# 3 C 3  27.50
# 4 D 4  36.25
# 5 D 5  45.00
# 6 D 6 -10.00
```

## En r√©sum√©

Le dataframe √©tant un objet √† mi-chemin entre une liste et une matrice, il partage les fa√ßons de s√©lectionner de ces deux types :

- Vous pouvez s√©lectionner selon un **indice** ou un **vecteur d‚Äôindice**, sur les lignes, les colonnes ou les deux en m√™me temps.
- Vous pouvez s√©lectionner en pr√©cisant le nom associ√© √† la colonne d‚Äôun dataframe.
- Vous pouvez s√©lectionner selon une condition qui ne va conserver que les lignes qui satisfont ladite condition.
- Et il est tout √† fait possible de mixer ces diff√©rentes m√©thodes pour arriver √† une s√©lection bien pr√©cise !

## S√©lection par position

Comme avec les matrices, il est possible de sp√©cifier des lignes et/ou colonnes √† s√©lectionner. Voici un exemple avec une s√©lection des 4 premi√®res lignes et des colonnes 2 et 3 :

```R
mondf[1:4,2:3]
#   y     z
# 1 1 10.00
# 2 2 18.75
# 3 3 27.50
# 4 4 36.25
```

Nous pouvons, tout comme avec une liste, s√©lectionner via un nom associ√© √† une colonne au sein du dataframe :

```R
mondf$z
# [1] 10.00 18.75 27.50 36.25 45.00 -10.00

mondf["z"]
#        z
# 1  10.00
# 2  18.75
# 3  27.50
# 4  36.25
# 5  45.00
# 6 -10.00
```

Il est √©galement possible de pouvoir mixer les deux. Par exemple ici, nous s√©lectionnons les lignes 2 √† 4 de la colonne `x` :

```R
mondf$x[2:4]
# [1] B C D
# Levels: A B C D
```

> Notez ici que le vecteur de caract√®res a √©t√© automatiquement modifi√© en **facteur** par R lors de la cr√©ation du dataframe. Si jamais vous souhaitez √©viter cela, vous devrez pr√©ciser l‚Äôargument `stringsAsFactors = FALSE` lors de la cr√©ation du dataframe !

## S√©lection par conditions

M√™me s‚Äôil arrive de s√©lectionner par indice, il est g√©n√©ralement plus courant de devoir s√©lectionner selon une condition. Par exemple, la ligne suivante permet de s√©lectionner toutes les lignes qui satisfont la condition sp√©cifi√©e :

```R
mondf[mondf$y>4,]
#   x y   z
# 5 D 5  45
# 6 D 6 -10

mondf[(mondf$y>4)|(mondf$z>17),]
#   x y      z
# 2 B 2  18.75
# 3 C 3  27.50
# 4 D 4  36.25
# 5 D 5  45.00
# 6 D 6 -10.00

mondf[(mondf$y>4)&(mondf$z>17),]
#   x y   z
# 5 D 5  45
```

Vous noterez que, lors de la construction de vos conditions, il est indispensable de repr√©ciser l‚Äôassociation `dataframe$colonne`, m√™me si le nom associ√© √† une colonne d‚Äôun dataframe est forc√©ment unique. Vous pouvez √©galement pr√©ciser une ou plusieurs colonnes en particulier :

```R
mondf[mondf$y>4,1:2] # √©quivalent √†
mondf[mondf$y>4,c('x','y')]
#   x y
# 5 D 5
# 6 D 6
```

######

######

# S√©lection dans une liste

Pour extraire une composante de la liste, on peut toujours le faire en indiquant la position de l‚Äô√©l√©ment que l‚Äôon souhaite extraire.

## En r√©sum√©

Il existe diff√©rentes fa√ßons de s√©lectionner au sein d‚Äôune liste :

- soit c‚Äôest une s√©lection par **position**. Cependant, il faut bien √™tre vigilant √† la diff√©rence entre une s√©lection via `[ ]` qui renverra une sous-liste de la liste originale et une s√©lection via `[[ ]]` qui renverra l‚Äôobjet stock√© dans la liste √† laquelle on essaie d‚Äôacc√©der ;
- soit c‚Äôest une s√©lection par nom, o√π l‚Äôon peut acc√©der √† une sous-liste ou un objet sp√©cifique en utilisant le nom qui y est associ√© au sein de la liste.

## S√©lection par position

Les `[[ ]]` permettent de retourner l‚Äô√©l√©ment de la liste. Il faut faire la distinction entre :

- `maliste[1]` qui retourne une sous-liste compos√©e de l‚Äô√©l√©ment 1 de la liste initiale. `length(maliste[1])` vaut donc 1.
- `maliste[[1]]` qui retourne l‚Äôobjet R qui compose l‚Äô√©l√©ment 1 de la liste. `length(maliste[[1]])` retourne la longueur de l‚Äôobjet stock√© en premier dans la liste `maliste`.

Commen√ßons par cr√©er une liste de 4 √©l√©ments.

```R
x <- c("a","a","b","c")
X <- matrix(1:8,ncol=4)
y <- c(T,T,T,F,F)
z <- matrix(c("A","B","C","D"),ncol=2)

maliste <- list(comp1=x,comp2=X,comp3=y,element4=z)
maliste
# $comp1
# [1] "a" "a" "b" "c"
#
# $comp2
#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    2    4    6    8
#
# $comp3
# [1]  TRUE  TRUE  TRUE FALSE FALSE
#
# $element4
#      [,1] [,2]
# [1,] "A"  "C"
# [2,] "B"  "D"
```

Voyons √† pr√©sent les diff√©rences notables entre la s√©lection avec l‚Äôop√©rateur `[ ]` et celle avec l‚Äôop√©rateur `[[ ]]` au sein de notre liste de 4 objets :

```R
maliste[2] #retourne une liste
# $comp2
#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    2    4    6    8

length(maliste[2])
# [1] 1

maliste[[2]] #extrait le second √©l√©ment de la liste
#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    2    4    6    8

length(maliste[[2]])
# [1] 8
# puisqu‚Äôil y a 8 √©l√©ments dans la composante 2 de maliste.
```

## S√©lection par nom

Lorsque vous souhaitez s√©lectionner au sein d‚Äôune liste en utilisant directement le nom d‚Äôun des objets qu‚Äôelle contient, vous pouvez l‚Äô√©crire de deux fa√ßons :

- soit de fa√ßon similaire √† une s√©lection par position en pr√©cisant le nom entre quotes,
- soit via l‚Äôop√©rateur `$`.

Par exemple :

```R
maliste["comp2"]
# $comp2
#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    2    4    6    8

maliste[["comp2"]]
#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    2    4    6    8

maliste$comp2
#      [,1] [,2] [,3] [,4]
# [1,]    1    3    5    7
# [2,]    2    4    6    8
```

> Notez bien ici encore une fois la diff√©rence entre l‚Äôop√©rateur `[ ]` qui renvoie une sous-liste et l‚Äôop√©rateur `[[ ]]` qui renvoie l‚Äôobjet que l‚Äôon souhaite s√©lectionner.

Il est possible d‚Äôextraire plusieurs √©l√©ments d‚Äôune m√™me liste, ce qui cr√©e une sous-liste. Noter qu‚Äôici l‚Äôon utilise `[ ]` et non `[[ ]]` :

```R
maliste[c(1,3)]
# $comp1
# [1] "a" "a" "b" "c"
#
# $comp3
# [1]  TRUE  TRUE  TRUE FALSE FALSE
```

######

Tags : #r #matrice
R√©sum√© :

Il est possible de s√©lectionner au sein d‚Äôune matrice selon
un entier positif ou un vecteur d‚Äôentiers positifs : pour pouvoir s√©lectionner en particulier une ligne ou une colonne. Un cas particulier est de sp√©cifier un num√©ro de ligne et de colonne dans le cas o√π vous souhaiteriez ne s√©lectionner qu‚Äôun seul √©l√©ment bien identifi√© ;

un entier n√©gatif ou un vecteur d‚Äôentiers n√©gatifs : pour exclure du r√©sultat final les √©l√©ments dont les indices sont repr√©sent√©s par les entiers ;

une condition : d√©finie soit sur les lignes, soit sur les colonnes, voire les deux en m√™me temps.

---

# S√©lection dans une matrice

L‚Äôemplacement d‚Äôun √©l√©ment dans une matrice est en g√©n√©ral donn√© par le num√©ro de sa ligne `i` et de sa colonne `j`. Ainsi, pour s√©lectionner l‚Äô√©l√©ment `(i, j)` de la matrice `m`, il faut √©crire : `m[i,j]`. Cependant, il est rare de ne s√©lectionner qu'un seul √©l√©ment dans une matrice. On s√©lectionne plus souvent une ou plusieurs lignes et/ou colonnes.

## S√©lection par indices

Le premier cas est la s√©lection par des entiers positifs : `m[i,]`. On retourne la ligne `i` sous la forme d‚Äôun vecteur. Pour conserver la structure de matrice il faut ajouter l‚Äôargument `drop` : `m[i, , drop=F]`. donne la ligne `i` sous la forme d‚Äôune matrice uniligne et non plus d‚Äôun vecteur, ce qui permet de conserver le nom de la ligne.

Il est possible de s√©lectionner plusieurs fois la m√™me ligne et/ou colonne gr√¢ce √† la synthaxe : `m[,c(2,2,1)]`. Cette synthaxe retourne aucune ligne, ainsi que deux fois la seconde colonne, puis une fois la premi√®re colonne : c‚Äôest donc une matrice √† trois colonnes.

Tout comme avec les vecteurs, il est possible de faire une selection avec des entiers n√©gatifs, pour √©liminer des √©l√©ments :

```r
# La matrice, m, sans sa premi√®re ligne

m[-1,]

# Les deux premi√®res lignes de la matrice m, priv√©e de sa premi√®re colonne

m[1:2,-1]
```

## S√©lection par conditions

On peut √©galement s√©lectionner selon une condition, d√©finie soit sur les lignes, soit sur les colonnes, voire les deux en m√™me temps !

```r
X <- matrix(1:12,nrow=3,ncol=4)
X
#      [,1] [,2] [,3] [,4]
# [1,]    1    4    7   10
# [2,]    2    5    8   11
# [3,]    3    6    9   12
```

L‚Äôinstruction suivante retourne uniquement les colonnes de X pour lesquelles la valeur sur la premi√®re ligne est strictement sup√©rieure √† 2 :

```r
X[,X[1,]>2]
#      [,1] [,2] [,3]
# [1,]    4    7   10
# [2,]    5    8   11
# [3,]    6    9   12
```

C‚Äôest donc une matrice, alors que l‚Äôinstruction suivante retourne un vecteur contenant les valeurs de X sup√©rieures √† 2 :

```r
X[X>2]
# [1]  3  4  5  6  7  8  9 10 11 12
```

L‚Äôinstruction suivante quant √† elle remplace les valeurs de X inf√©rieures √† 5 par des NA

```r
X[X<5] <- NA
#      [,1] [,2] [,3] [,4]
# [1,]   NA   NA    7   10
# [2,]   NA    5    8   11
# [3,]   NA    6    9   12
```

########
